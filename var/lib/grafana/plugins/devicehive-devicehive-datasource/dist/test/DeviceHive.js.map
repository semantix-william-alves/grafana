{"version":3,"sources":["../../src/DeviceHive.js"],"names":["DeviceHive","serverUrl","login","password","accessToken","refreshToken","me","socket","WebSocket","isOpen","isAuthenticated","isTokenRequested","isAuthenticationStarted","addEventListener","Error","messageObject","_getReadyClient","then","action","Promise","resolve","authenticate","reject","requestId","uniqueId","send","JSON","stringify","listener","event","messageData","parse","data","isSuccess","status","removeEventListener","error","token","once","dispatchEvent","catch","_refreshToken","result","onOpen"],"mappings":";;;;;;;;AAAA;;;;AACA;;;;;;;;;;;;AAIA;;;IAGMA,U;;;AAEF;;;;;AAKA,8BAAuE;AAAA,YAAzDC,SAAyD,QAAzDA,SAAyD;AAAA,YAA9CC,KAA8C,QAA9CA,KAA8C;AAAA,YAAvCC,QAAuC,QAAvCA,QAAuC;AAAA,YAA7BC,WAA6B,QAA7BA,WAA6B;AAAA,YAAhBC,YAAgB,QAAhBA,YAAgB;;AAAA;;AAAA;;AAGnE,YAAMC,UAAN;;AAEA,YAAIL,cAAeC,SAASC,QAAV,IAAwBC,eAAeC,YAArD,CAAJ,EAAyE;AACrEC,eAAGC,MAAH,GAAY,IAAIC,SAAJ,CAAcP,SAAd,CAAZ;AACAK,eAAGJ,KAAH,GAAWA,KAAX;AACAI,eAAGH,QAAH,GAAcA,QAAd;AACAG,eAAGL,SAAH,GAAeA,SAAf;AACAK,eAAGF,WAAH,GAAiBA,WAAjB;AACAE,eAAGD,YAAH,GAAkBA,YAAlB;AACAC,eAAGG,MAAH,GAAY,KAAZ;AACAH,eAAGI,eAAH,GAAqB,KAArB;AACAJ,eAAGK,gBAAH,GAAsB,KAAtB;AACAL,eAAGM,uBAAH,GAA6B,KAA7B;;AAEAN,eAAGC,MAAH,CAAUM,gBAAV,SAAmC;AAAA,uBAAMP,GAAGG,MAAH,GAAY,IAAlB;AAAA,aAAnC;AACAH,eAAGC,MAAH,CAAUM,gBAAV,UAAoC;AAAA,uBAAMP,GAAGG,MAAH,GAAY,KAAlB;AAAA,aAApC;AACH,SAdD,MAcO;AACH,kBAAM,IAAIK,KAAJ,+DAAN;AACH;AArBkE;AAsBtE;;AAED;;;;;;;;;6BAKKC,a,EAAe;AAChB,gBAAMT,KAAK,IAAX;;AAEA,mBAAOA,GAAGU,eAAH,GACFC,IADE,CACG,YAAM;AACR,uBAAOX,GAAGI,eAAH,KAAuB,IAAvB,IACHK,cAAcG,MAAd,mBADG,IAEHH,cAAcG,MAAd,oBAFG,IAGHH,cAAcG,MAAd,YAHG,GAIHC,QAAQC,OAAR,EAJG,GAIiBd,GAAGe,YAAH,EAJxB;AAKH,aAPE,EAQFJ,IARE,CAQG;AAAA,uBAAM,IAAIE,OAAJ,CAAY,UAACC,OAAD,EAAUE,MAAV,EAAqB;AACzCP,kCAAcQ,SAAd,GAA0BR,cAAcQ,SAAd,IAA2B,iBAAOC,QAAP,iBAArD;AACAlB,uBAAGC,MAAH,CAAUkB,IAAV,CAAeC,KAAKC,SAAL,CAAeZ,aAAf,CAAf;;AAEA,wBAAMa,WAAW,SAAXA,QAAW,CAACC,KAAD,EAAW;AACxB,4BAAMC,cAAcJ,KAAKK,KAAL,CAAWF,MAAMG,IAAjB,CAApB;AACA,4BAAMC,YAAYH,YAAYI,MAAZ,cAAlB;;AAEA,4BAAIJ,YAAYZ,MAAZ,KAAuBH,cAAcG,MAArC,IACAY,YAAYP,SAAZ,KAA0BR,cAAcQ,SAD5C,EACuD;AACnDjB,+BAAGC,MAAH,CAAU4B,mBAAV,YAAyCP,QAAzC;AACAtB,+BAAGI,eAAH,GAAqBuB,cAAc,KAAd,GAAsBA,SAAtB,GAAkC3B,GAAGI,eAA1D;AACAuB,wCAAYb,QAAQU,WAAR,CAAZ,GAAmCR,OAAOQ,YAAYM,KAAnB,CAAnC;AACH;AACJ,qBAVD;;AAYA9B,uBAAGC,MAAH,CAAUM,gBAAV,YAAsCe,QAAtC;AACH,iBAjBW,CAAN;AAAA,aARH,CAAP;AA0BH;;AAED;;;;;;;;uCAK8C;AAAA,4FAAJ,EAAI;AAAA,gBAA/BS,KAA+B,SAA/BA,KAA+B;AAAA,gBAAxBnC,KAAwB,SAAxBA,KAAwB;AAAA,gBAAjBC,QAAiB,SAAjBA,QAAiB;;AAC1C,gBAAMG,KAAK,IAAX;;AAEAA,eAAGF,WAAH,GAAiBiC,SAAS/B,GAAGF,WAA7B;AACAE,eAAGJ,KAAH,GAAWA,SAASI,GAAGJ,KAAvB;AACAI,eAAGH,QAAH,GAAcA,YAAYG,GAAGH,QAA7B;;AAEA,mBAAO,IAAIgB,OAAJ,CAAY,UAACC,OAAD,EAAUE,MAAV,EAAqB;AACpChB,mBAAGgC,IAAH,kBAAyB,YAAM;AAC3BhC,uBAAGK,gBAAH,GAAsB,KAAtB;AACAL,uBAAGM,uBAAH,GAA6B,KAA7B;AACAN,uBAAGI,eAAH,GAAqB,IAArB;AACAU;AACH,iBALD;;AAOA,oBAAId,GAAGI,eAAH,KAAuB,IAA3B,EAAiC;AAC7BJ,uBAAGiC,aAAH;AACH,iBAFD,MAEO;AACH,wBAAIjC,GAAGM,uBAAH,KAA+B,KAA/B,IAAwCN,GAAGK,gBAAH,KAAwB,KAApE,EAA2E;AACvE,4BAAIL,GAAGF,WAAH,IAAkBE,GAAGD,YAAzB,EAAuC;AACnCC,+BAAGM,uBAAH,GAA6B,IAA7B;AACAN,+BAAGmB,IAAH,CAAQ,EAACP,sBAAD,EAAyBmB,OAAO/B,GAAGF,WAAnC,EAAR,EACKa,IADL,CACU;AAAA,uCAAMX,GAAGiC,aAAH,iBAAN;AAAA,6BADV,EAEKC,KAFL,CAEW,UAACJ,KAAD;AAAA,uCAAW9B,GAAGD,YAAH,GAAkBC,GAAGmC,aAAH,EAAlB,GAAuCtB,QAAQG,MAAR,CAAec,KAAf,CAAlD;AAAA,6BAFX,EAGKnB,IAHL,CAGU,UAACyB,MAAD;AAAA,uCAAYA,OAAOtC,WAAP,GACdE,GAAGe,YAAH,CAAgB,EAAEgB,OAAOK,OAAOtC,WAAhB,EAAhB,CADc,GACmCe,QAAQC,OAAR,EAD/C;AAAA,6BAHV,EAKKoB,KALL,CAKW,UAACJ,KAAD;AAAA,uCAAWd,OAAOc,KAAP,CAAX;AAAA,6BALX;AAMH,yBARD,MAQO;AACH9B,+BAAGK,gBAAH,GAAsB,IAAtB;AACAL,+BAAGmB,IAAH,CAAQ,EAACP,eAAD,EAAkBhB,OAAOI,GAAGJ,KAA5B,EAAmCC,UAAUG,GAAGH,QAAhD,EAAR,EACKc,IADL,CACU,iBAAmC;AAAA,oCAAhCb,WAAgC,SAAhCA,WAAgC;AAAA,oCAAnBC,YAAmB,SAAnBA,YAAmB;;AACrCC,mCAAGF,WAAH,GAAiBA,WAAjB;AACAE,mCAAGD,YAAH,GAAkBA,YAAlB;;AAEA,uCAAOC,GAAGe,YAAH,CAAgB,EAAEgB,OAAOjC,WAAT,EAAhB,CAAP;AACH,6BANL,EAOKoC,KAPL,CAOW,UAACJ,KAAD;AAAA,uCAAWd,OAAOc,KAAP,CAAX;AAAA,6BAPX;AAQH;AACJ;AACJ;AACJ,aAjCM,CAAP;AAkCH;;AAED;;;;;;;;wCAKgB;AACZ,gBAAM9B,KAAK,IAAX;;AAEA,mBAAOA,GAAGmB,IAAH,CAAQ;AACXP,uCADW;AAEXb,8BAAcC,GAAGD;AAFN,aAAR,CAAP;AAIH;;AAED;;;;;;;;0CAKkB;AACd,gBAAMC,KAAK,IAAX;;AAEA,qBAASqC,MAAT,CAAgBvB,OAAhB,EAAyB;AACrBd,mBAAGC,MAAH,CAAU4B,mBAAV,SAAsCQ,MAAtC;AACAvB,wBAAQd,EAAR;AACH;;AAED,mBAAO,IAAIa,OAAJ,CAAY,UAACC,OAAD;AAAA,uBAAad,GAAGG,MAAH,GAAYW,QAAQd,EAAR,CAAZ,GAA0BA,GAAGC,MAAH,CAAUM,gBAAV,SAAmC;AAAA,2BAAM8B,OAAOvB,OAAP,CAAN;AAAA,iBAAnC,CAAvC;AAAA,aAAZ,CAAP;AACH;;;;;;kBAIUpB,U","file":"DeviceHive.js","sourcesContent":["import lodash from \"lodash\";\r\nimport Events from \"./utils/Events\";\r\n\r\n\r\n\r\n/**\r\n * DeviceHive api class\r\n */\r\nclass DeviceHive extends Events {\r\n\r\n    /**\r\n     * Creates an instance of DeviceHive.\r\n     * @param {Object} { serverUrl, login, password, accessToken, refreshToken }\r\n     * @memberof DeviceHive\r\n     */\r\n    constructor({ serverUrl, login, password, accessToken, refreshToken }) {\r\n        super();\r\n\r\n        const me = this;\r\n\r\n        if (serverUrl && ((login && password) || (accessToken || refreshToken))) {\r\n            me.socket = new WebSocket(serverUrl);\r\n            me.login = login;\r\n            me.password = password;\r\n            me.serverUrl = serverUrl;\r\n            me.accessToken = accessToken;\r\n            me.refreshToken = refreshToken;\r\n            me.isOpen = false;\r\n            me.isAuthenticated = false;\r\n            me.isTokenRequested = false;\r\n            me.isAuthenticationStarted = false;\r\n\r\n            me.socket.addEventListener(`open`, () => me.isOpen = true);\r\n            me.socket.addEventListener(`close`, () => me.isOpen = false);\r\n        } else {\r\n            throw new Error(`You need to specify URL, login and password or Access Token`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send message object over WS session by the key\r\n     * @param messageObject\r\n     * @return {Promise}\r\n     */\r\n    send(messageObject) {\r\n        const me = this;\r\n\r\n        return me._getReadyClient()\r\n            .then(() => {\r\n                return me.isAuthenticated === true ||\r\n                    messageObject.action === `authenticate` ||\r\n                    messageObject.action === `token/refresh` ||\r\n                    messageObject.action === `token` ?\r\n                    Promise.resolve() : me.authenticate();\r\n            })\r\n            .then(() => new Promise((resolve, reject) => {\r\n                messageObject.requestId = messageObject.requestId || lodash.uniqueId(`deviceHiveId_`);\r\n                me.socket.send(JSON.stringify(messageObject));\r\n\r\n                const listener = (event) => {\r\n                    const messageData = JSON.parse(event.data);\r\n                    const isSuccess = messageData.status === `success`;\r\n\r\n                    if (messageData.action === messageObject.action &&\r\n                        messageData.requestId === messageObject.requestId) {\r\n                        me.socket.removeEventListener(`message`, listener);\r\n                        me.isAuthenticated = isSuccess === false ? isSuccess : me.isAuthenticated;\r\n                        isSuccess ? resolve(messageData) : reject(messageData.error);\r\n                    }\r\n                };\r\n\r\n                me.socket.addEventListener(`message`, listener);\r\n            }));\r\n    }\r\n\r\n    /**\r\n     * Internal `authenticate` message sender\r\n     * @param {String} accessToken\r\n     * @memberof DeviceHive\r\n     */\r\n    authenticate({ token, login, password } = {}) {\r\n        const me = this;\r\n\r\n        me.accessToken = token || me.accessToken;\r\n        me.login = login || me.login;\r\n        me.password = password || me.password;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            me.once(`authenticated`, () => {\r\n                me.isTokenRequested = false;\r\n                me.isAuthenticationStarted = false;\r\n                me.isAuthenticated = true;\r\n                resolve();\r\n            });\r\n\r\n            if (me.isAuthenticated === true) {\r\n                me.dispatchEvent(`authenticated`);\r\n            } else {\r\n                if (me.isAuthenticationStarted === false || me.isTokenRequested === false) {\r\n                    if (me.accessToken || me.refreshToken) {\r\n                        me.isAuthenticationStarted = true;\r\n                        me.send({action: `authenticate`, token: me.accessToken})\r\n                            .then(() => me.dispatchEvent(`authenticated`))\r\n                            .catch((error) => me.refreshToken ? me._refreshToken() : Promise.reject(error))\r\n                            .then((result) => result.accessToken ?\r\n                                me.authenticate({ token: result.accessToken }) : Promise.resolve())\r\n                            .catch((error) => reject(error));\r\n                    } else {\r\n                        me.isTokenRequested = true;\r\n                        me.send({action: `token`, login: me.login, password: me.password})\r\n                            .then(({ accessToken, refreshToken }) => {\r\n                                me.accessToken = accessToken;\r\n                                me.refreshToken = refreshToken;\r\n\r\n                                return me.authenticate({ token: accessToken })\r\n                            })\r\n                            .catch((error) => reject(error));\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Refresh access token\r\n     * @returns {Promise}\r\n     * @private\r\n     */\r\n    _refreshToken() {\r\n        const me = this;\r\n\r\n        return me.send({\r\n            action: `token/refresh`,\r\n            refreshToken: me.refreshToken\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Waits for WS session to be opened\r\n     * @return {Promise}\r\n     * @private\r\n     */\r\n    _getReadyClient() {\r\n        const me = this;\r\n\r\n        function onOpen(resolve) {\r\n            me.socket.removeEventListener(`open`, onOpen);\r\n            resolve(me)\r\n        }\r\n\r\n        return new Promise((resolve) => me.isOpen ? resolve(me) : me.socket.addEventListener(`open`, () => onOpen(resolve)));\r\n    }\r\n}\r\n\r\n\r\nexport default DeviceHive;"]}