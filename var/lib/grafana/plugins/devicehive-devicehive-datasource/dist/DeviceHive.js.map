{"version":3,"sources":["../src/DeviceHive.js"],"names":["lodash","Events","DeviceHive","serverUrl","login","password","accessToken","refreshToken","me","socket","WebSocket","isOpen","isAuthenticated","isTokenRequested","isAuthenticationStarted","addEventListener","Error","messageObject","_getReadyClient","then","action","Promise","resolve","authenticate","reject","requestId","uniqueId","send","JSON","stringify","listener","event","messageData","parse","data","isSuccess","status","removeEventListener","error","token","once","dispatchEvent","catch","_refreshToken","result","onOpen"],"mappings":"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","file":"DeviceHive.js","sourcesContent":["import lodash from \"lodash\";\r\nimport Events from \"./utils/Events\";\r\n\r\n\r\n\r\n/**\r\n * DeviceHive api class\r\n */\r\nclass DeviceHive extends Events {\r\n\r\n    /**\r\n     * Creates an instance of DeviceHive.\r\n     * @param {Object} { serverUrl, login, password, accessToken, refreshToken }\r\n     * @memberof DeviceHive\r\n     */\r\n    constructor({ serverUrl, login, password, accessToken, refreshToken }) {\r\n        super();\r\n\r\n        const me = this;\r\n\r\n        if (serverUrl && ((login && password) || (accessToken || refreshToken))) {\r\n            me.socket = new WebSocket(serverUrl);\r\n            me.login = login;\r\n            me.password = password;\r\n            me.serverUrl = serverUrl;\r\n            me.accessToken = accessToken;\r\n            me.refreshToken = refreshToken;\r\n            me.isOpen = false;\r\n            me.isAuthenticated = false;\r\n            me.isTokenRequested = false;\r\n            me.isAuthenticationStarted = false;\r\n\r\n            me.socket.addEventListener(`open`, () => me.isOpen = true);\r\n            me.socket.addEventListener(`close`, () => me.isOpen = false);\r\n        } else {\r\n            throw new Error(`You need to specify URL, login and password or Access Token`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send message object over WS session by the key\r\n     * @param messageObject\r\n     * @return {Promise}\r\n     */\r\n    send(messageObject) {\r\n        const me = this;\r\n\r\n        return me._getReadyClient()\r\n            .then(() => {\r\n                return me.isAuthenticated === true ||\r\n                    messageObject.action === `authenticate` ||\r\n                    messageObject.action === `token/refresh` ||\r\n                    messageObject.action === `token` ?\r\n                    Promise.resolve() : me.authenticate();\r\n            })\r\n            .then(() => new Promise((resolve, reject) => {\r\n                messageObject.requestId = messageObject.requestId || lodash.uniqueId(`deviceHiveId_`);\r\n                me.socket.send(JSON.stringify(messageObject));\r\n\r\n                const listener = (event) => {\r\n                    const messageData = JSON.parse(event.data);\r\n                    const isSuccess = messageData.status === `success`;\r\n\r\n                    if (messageData.action === messageObject.action &&\r\n                        messageData.requestId === messageObject.requestId) {\r\n                        me.socket.removeEventListener(`message`, listener);\r\n                        me.isAuthenticated = isSuccess === false ? isSuccess : me.isAuthenticated;\r\n                        isSuccess ? resolve(messageData) : reject(messageData.error);\r\n                    }\r\n                };\r\n\r\n                me.socket.addEventListener(`message`, listener);\r\n            }));\r\n    }\r\n\r\n    /**\r\n     * Internal `authenticate` message sender\r\n     * @param {String} accessToken\r\n     * @memberof DeviceHive\r\n     */\r\n    authenticate({ token, login, password } = {}) {\r\n        const me = this;\r\n\r\n        me.accessToken = token || me.accessToken;\r\n        me.login = login || me.login;\r\n        me.password = password || me.password;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            me.once(`authenticated`, () => {\r\n                me.isTokenRequested = false;\r\n                me.isAuthenticationStarted = false;\r\n                me.isAuthenticated = true;\r\n                resolve();\r\n            });\r\n\r\n            if (me.isAuthenticated === true) {\r\n                me.dispatchEvent(`authenticated`);\r\n            } else {\r\n                if (me.isAuthenticationStarted === false || me.isTokenRequested === false) {\r\n                    if (me.accessToken || me.refreshToken) {\r\n                        me.isAuthenticationStarted = true;\r\n                        me.send({action: `authenticate`, token: me.accessToken})\r\n                            .then(() => me.dispatchEvent(`authenticated`))\r\n                            .catch((error) => me.refreshToken ? me._refreshToken() : Promise.reject(error))\r\n                            .then((result) => result.accessToken ?\r\n                                me.authenticate({ token: result.accessToken }) : Promise.resolve())\r\n                            .catch((error) => reject(error));\r\n                    } else {\r\n                        me.isTokenRequested = true;\r\n                        me.send({action: `token`, login: me.login, password: me.password})\r\n                            .then(({ accessToken, refreshToken }) => {\r\n                                me.accessToken = accessToken;\r\n                                me.refreshToken = refreshToken;\r\n\r\n                                return me.authenticate({ token: accessToken })\r\n                            })\r\n                            .catch((error) => reject(error));\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Refresh access token\r\n     * @returns {Promise}\r\n     * @private\r\n     */\r\n    _refreshToken() {\r\n        const me = this;\r\n\r\n        return me.send({\r\n            action: `token/refresh`,\r\n            refreshToken: me.refreshToken\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Waits for WS session to be opened\r\n     * @return {Promise}\r\n     * @private\r\n     */\r\n    _getReadyClient() {\r\n        const me = this;\r\n\r\n        function onOpen(resolve) {\r\n            me.socket.removeEventListener(`open`, onOpen);\r\n            resolve(me)\r\n        }\r\n\r\n        return new Promise((resolve) => me.isOpen ? resolve(me) : me.socket.addEventListener(`open`, () => onOpen(resolve)));\r\n    }\r\n}\r\n\r\n\r\nexport default DeviceHive;"]}