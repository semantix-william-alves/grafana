{"version":3,"sources":["../src/variablesHelper.js"],"names":["_","VariablesHelper","templateSrv","target","options","variableNames","variables","map","v","name","resolved","forEach","indexOf","values","getVarValues","scopedVars","newResolved","regex","RegExp","push","newTarget","replace","val","isArray","join","charAt","substring","length","split","variableExists"],"mappings":";;;;;;;;;;;;;;;AAAOA,O;;;;;;;;;;;;;;;;;;;;;iCAEMC,e;AAEX,iCAAYC,WAAZ,EAAyB;AAAA;;AACvB,eAAKA,WAAL,GAAmBA,WAAnB;AACD;;;;kCAEOC,M,EAAQC,O,EAAS;AAAA;;AACvB,gBAAMC,gBAAgB,CAAC,KAAKH,WAAL,CAAiBI,SAAjB,IAA8B,EAA/B,EAAmCC,GAAnC,CAAuC;AAAA,qBAAK,MAAMC,EAAEC,IAAb;AAAA,aAAvC,CAAtB;AACA;AACA,gBAAIC,WAAW,CAACP,MAAD,CAAf;AACA,gBAAIE,aAAJ,EAAmB;AACjBA,4BAAcM,OAAd,CAAsB,gBAAQ;AAC5B,oBAAIR,OAAOS,OAAP,CAAeH,IAAf,KAAwB,CAA5B,EAA+B;AAC7B,sBAAMI,SAAS,MAAKC,YAAL,CAAkBL,IAAlB,EAAwBL,QAAQW,UAAhC,CAAf;AACA,sBAAMC,cAAc,EAApB;AACA,sBAAMC,QAAQ,IAAIC,MAAJ,CAAW,OAAOT,IAAlB,EAAwB,GAAxB,CAAd;AACAI,yBAAOF,OAAP,CAAe,eAAO;AACpBD,6BAASC,OAAT,CAAiB,qBAAa;AAC5BK,kCAAYG,IAAZ,CAAiBC,UAAUC,OAAV,CAAkBJ,KAAlB,EAAyBK,GAAzB,CAAjB;AACD,qBAFD;AAGD,mBAJD;AAKAZ,6BAAWM,WAAX;AACD;AACF,eAZD;AAaD;AACD,mBAAON,QAAP;AACD;;;uCAEYP,M,EAAQC,O,EAAS;AAC5B,mBAAO,KAAKF,WAAL,CAAiBmB,OAAjB,CAAyBlB,MAAzB,EAAiCC,QAAQW,UAAzC,EAAqD,kBAAU;AACpE,kBAAIf,EAAEuB,OAAF,CAAUV,MAAV,CAAJ,EAAuB;AACrB,uBAAOA,OAAON,GAAP,CAAW;AAAA,gCAASC,CAAT;AAAA,iBAAX,EAA0BgB,IAA1B,CAA+B,GAA/B,CAAP;AACD;AACD,4BAAWX,MAAX;AACD,aALM,CAAP;AAMD;;;uCAEYJ,I,EAAMM,U,EAAY;AAC7B,gBAAMF,SAAS,KAAKX,WAAL,CAAiBmB,OAAjB,CAAyBZ,IAAzB,EAA+BM,UAA/B,CAAf;AACA;AACA,gBAAIF,OAAOY,MAAP,CAAc,CAAd,MAAqB,GAAzB,EAA8B;AAC1B,qBAAOZ,OAAOa,SAAP,CAAiB,CAAjB,EAAoBb,OAAOc,MAAP,GAAc,CAAlC,EAAqCC,KAArC,CAA2C,GAA3C,CAAP;AACH;AACD,mBAAO,CAACf,MAAD,CAAP;AACD;;;iCAEMJ,I,EAAM;AACX,mBAAO,KAAKP,WAAL,CAAiB2B,cAAjB,CAAgCpB,IAAhC,CAAP;AACD","file":"variablesHelper.js","sourcesContent":["import _ from 'lodash';\n\nexport class VariablesHelper {\n\n  constructor(templateSrv) {\n    this.templateSrv = templateSrv;\n  }\n\n  resolve(target, options) {\n    const variableNames = (this.templateSrv.variables || []).map(v => '$' + v.name);\n    // For each variable in target, and each values of a given variable, build a resolved target string\n    let resolved = [target];\n    if (variableNames) {\n      variableNames.forEach(name => {\n        if (target.indexOf(name) >= 0) {\n          const values = this.getVarValues(name, options.scopedVars);\n          const newResolved = [];\n          const regex = new RegExp('\\\\' + name, 'g');\n          values.forEach(val => {\n            resolved.forEach(newTarget => {\n              newResolved.push(newTarget.replace(regex, val));\n            });\n          });\n          resolved = newResolved;\n        }\n      });\n    }\n    return resolved;\n  }\n\n  resolveForQL(target, options) {\n    return this.templateSrv.replace(target, options.scopedVars, values => {\n      if (_.isArray(values)) {\n        return values.map(v => `'${v}'`).join(',');\n      }\n      return `'${values}'`;\n    });\n  }\n\n  getVarValues(name, scopedVars) {\n    const values = this.templateSrv.replace(name, scopedVars);\n    // result might be in like \"{id1,id2,id3}\" (as string)\n    if (values.charAt(0) === '{') {\n        return values.substring(1, values.length-1).split(',');\n    }\n    return [values];\n  }\n\n  exists(name) {\n    return this.templateSrv.variableExists(name);\n  }\n}\n"]}