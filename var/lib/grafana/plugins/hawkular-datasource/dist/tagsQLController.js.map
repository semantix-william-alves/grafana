{"version":3,"sources":["../src/tagsQLController.js"],"names":["convertFromKVPairs","kvTags","undefined","map","tag","value","name","charAt","join","segmentsToString","segments","strTags","i","length","type","tagName","op","OPERATOR_EQ","OPERATOR_NOTEQ","valueToString","OPERATOR_EXISTS","OPERATOR_NOTEXISTS","OPERATOR_IN","v","valuesToString","values","OPERATOR_NOTIN","sep","match","stringToSegments","segmentFactory","cursor","result","readLogicalOp","push","newCondition","readWord","toUpperCase","newKey","newOperator","nextCursor","skipWhile","c","OPERATOR_AND","OPERATOR_OR","readRelationalOp","newKeyValue","readEnumeration","substr","remaining","first","word","cond","skipWhileNextNotIn","nextList","expect","actual","TagsQLController","uiSegmentSrv","datasource","$q","targetSupplier","removeTagSegment","newSegment","fake","removeValueSegment","target","tagsQL","tags","newPlusButton","isInEnum","splice","segment","$index","when","newOperators","getContainingEnum","key","suggestTags","then","transformToSegments","getTagKeys","angular","copy","keys","promise","suggestTagKeys","index","nextSegment","needOneRightOperand","isEnum","currentRightOperands"],"mappings":"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","file":"tagsQLController.js","sourcesContent":["// \"Natural language\" operators\nconst OPERATOR_EQ = '=';\nconst OPERATOR_NOTEQ = '!=';\nconst OPERATOR_IN = 'is in';\nconst OPERATOR_NOTIN = 'is not in';\nconst OPERATOR_EXISTS = 'exists';\nconst OPERATOR_NOTEXISTS = 'doesn\\'t exist';\nconst OPERATOR_AND = 'AND';\nconst OPERATOR_OR = 'OR';\n\nexport class TagsQLController {\n\n  constructor(uiSegmentSrv, datasource, $q, targetSupplier)  {\n    this.uiSegmentSrv = uiSegmentSrv;\n    this.datasource = datasource;\n    this.$q = $q;\n    this.targetSupplier = targetSupplier;\n    this.removeTagSegment = uiSegmentSrv.newSegment({fake: true, value: '-- Remove tag --'});\n    this.removeValueSegment = uiSegmentSrv.newSegment({fake: true, value: '-- Remove value --'});\n  }\n\n  initTagsSegments() {\n    const target = this.targetSupplier();\n    if (!target.tagsQL && target.tags) {\n      // Compatibility, switching from older version\n      target.tagsQL = convertFromKVPairs(target.tags);\n    }\n    let segments = stringToSegments(target.tagsQL, this.uiSegmentSrv);\n    segments.push(this.uiSegmentSrv.newPlusButton());\n    // Fix plus-button: add it at the end of each enumeration\n    let isInEnum = false;\n    for (let i = 0; i < segments.length; i++) {\n      if (segments[i].type === 'operator' && (segments[i].value === OPERATOR_IN || segments[i].value === OPERATOR_NOTIN)) {\n        isInEnum = true;\n      } else if (isInEnum && segments[i].type !== 'value') {\n        segments.splice(i, 0, this.uiSegmentSrv.newPlusButton());\n        isInEnum = false;\n      }\n    }\n    return segments;\n  }\n\n  getTagsSegments(segments, segment, $index) {\n    // Get suggestions for available values in a given segment\n    if (segment.type === 'condition') {\n      return this.$q.when([this.uiSegmentSrv.newSegment(OPERATOR_AND), this.uiSegmentSrv.newSegment(OPERATOR_OR)]);\n    }\n    if (segment.type === 'operator') {\n      return this.$q.when(this.uiSegmentSrv.newOperators([OPERATOR_EQ, OPERATOR_NOTEQ, OPERATOR_EXISTS, OPERATOR_NOTEXISTS, OPERATOR_IN, OPERATOR_NOTIN]));\n    }\n    if (segment.type === 'plus-button') {\n      // Find previous operator to know if we're in an enumeration\n      let i = this.getContainingEnum(segments, $index);\n      if (i > 0) {\n        const key = segments[i-1].value;\n        return this.datasource.suggestTags(this.targetSupplier(), key)\n          .then(this.uiSegmentSrv.transformToSegments(false));\n      } else {\n        return this.getTagKeys();\n      }\n    } else if (segment.type === 'key')  {\n      return this.getTagKeys()\n          .then(keys => [angular.copy(this.removeTagSegment), ...keys]);\n    } else if (segment.type === 'value')  {\n      // Find preceding key\n      let i = $index - 2;\n      while (segments[i].type !== 'key') {\n        i--;\n      }\n      const key = segments[i].value;\n      let promise = this.datasource.suggestTags(this.targetSupplier(), key)\n        .then(this.uiSegmentSrv.transformToSegments(false));\n      if (segments[$index-1].type === 'value') {\n        // We're in an enumeration\n        promise = promise.then(values => [angular.copy(this.removeValueSegment), ...values]);\n      }\n      return promise;\n    }\n  }\n\n  // Returns -1 if not in enum, or the index of the operator if in enum\n  getContainingEnum(segments, $index) {\n    // Find previous operator to know if we're in an enumeration\n    let i = $index-1;\n    while (i >= 0) {\n      if (segments[i].type === 'operator') {\n        if (segments[i].value === OPERATOR_IN || segments[i].value === OPERATOR_NOTIN) {\n          return i;\n        }\n        return -1;\n      }\n      if (segments[i].type === 'plus-button') {\n        // There can be several plus-buttons. In that case, the user selected the last plus-button, ie. the one related to adding a new tag.\n        return -1;\n      }\n      i--;\n    }\n    return -1;\n  }\n\n  getTagKeys() {\n    return this.datasource.suggestTagKeys(this.targetSupplier())\n      .then(this.uiSegmentSrv.transformToSegments(false));\n  }\n\n  tagsSegmentChanged(segments, segment, index) {\n    if (segment.value === this.removeTagSegment.value) {\n      // Remove the whole tag sequence\n      // Compute number of segments to delete forward\n      let nextSegment = index + 1;\n      if (index > 0) {\n        // Also remove preceding AND/OR segment\n        index--;\n      }\n      while (nextSegment < segments.length) {\n        if (nextSegment === segments.length - 1) {\n          break;\n        }\n        if (segments[nextSegment].type === 'condition') {\n          if (index === 0) {\n            // Don't start query with a AND or OR, remove it.\n            nextSegment++;\n          }\n          break;\n        }\n        nextSegment++;\n      }\n      segments.splice(index, nextSegment - index);\n    } else if (segment.value === this.removeValueSegment.value) {\n      // We must be deleting a value from an enumeration\n      segments.splice(index, 1);\n    } else if (segment.type === 'plus-button') {\n      // Remove plus button\n      segments.splice(index, 1);\n      let i = this.getContainingEnum(segments, index);\n      if (i > 0) {\n        // We're in an enum, so add value\n        segments.splice(index, 0,\n          this.uiSegmentSrv.newKeyValue(segment.value),\n          this.uiSegmentSrv.newPlusButton());\n      } else {\n        // Add a default model for tag: \"<key> EXISTS\"\n        segments.splice(index, 0,\n          this.uiSegmentSrv.newKey(segment.value),\n          this.uiSegmentSrv.newOperator(OPERATOR_EXISTS),\n          this.uiSegmentSrv.newPlusButton());\n        if (index > 0) {\n          // Add leading \"AND\"\n          segments.splice(index, 0, this.uiSegmentSrv.newCondition(OPERATOR_AND));\n        }\n      }\n    } else {\n      if (segment.type === 'operator') {\n        // Is there a change in number of operands?\n        const needOneRightOperand = segment.value === OPERATOR_EQ || segment.value === OPERATOR_NOTEQ;\n        const isEnum = segment.value === OPERATOR_IN || segment.value === OPERATOR_NOTIN;\n        let currentRightOperands = 0;\n        while (segments[index+currentRightOperands+1].type === 'value') {\n          currentRightOperands++;\n        }\n        // If it's followed by a plus-button that is NOT the last element, then count it as a right operand as it must also be removed when we switch from enum to something else\n        if (segments[index+currentRightOperands+1].type === 'plus-button' && index+currentRightOperands+2 < segments.length) {\n          currentRightOperands++;\n        }\n        if (needOneRightOperand && currentRightOperands === 0) {\n          // Add tag value\n          segments.splice(index+1, 0, this.uiSegmentSrv.newKeyValue('select value'));\n        } else if (needOneRightOperand && currentRightOperands > 1) {\n          // Remove excedent\n          segments.splice(index+2, currentRightOperands-1);\n        } else if (!needOneRightOperand && !isEnum && currentRightOperands > 0) {\n          // Remove values\n          segments.splice(index+1, currentRightOperands);\n        } else if (isEnum) {\n          if (currentRightOperands === 0) {\n            // Add a value and plus-button\n            segments.splice(index+1, 0, this.uiSegmentSrv.newKeyValue('select value'), this.uiSegmentSrv.newPlusButton());\n          } else if (currentRightOperands === 1) {\n            // Just add plus-button after the value\n            segments.splice(index+2, 0, this.uiSegmentSrv.newPlusButton());\n          }\n        }\n      }\n      segments[index] = segment;\n    }\n    this.targetSupplier().tagsQL = segmentsToString(segments);\n  }\n}\n\nexport function convertFromKVPairs(kvTags) {\n  if (kvTags === undefined) {\n    return undefined;\n  }\n  return kvTags.map(tag => {\n    if (tag.value === '*' || tag.value === ' *') {\n      return tag.name;\n    }\n    if (tag.value.charAt(0) === '$') {\n      // it's a variable\n      return `${tag.name} IN [${tag.value}]`;\n    }\n    return `${tag.name}='${tag.value}'`;\n  }).join(' AND ');\n}\n\n// Example:\n// Input segment values: [\"fruit\", \"is in\", \"pear\", \"apple\", \"peach\", \"<plus-button>\", \"AND\", \"color\", \"=\", \"green\", \"<plus-button>\"]\n// Output string: \"fruit IN [pear, apple, peach] AND color=green\"\nexport function segmentsToString(segments) {\n  let strTags = '';\n  let i = 0;\n  while (i < segments.length) {\n    if (segments[i].type === 'plus-button') {\n      i++;\n      continue;\n    }\n    if (i != 0) {\n      // AND/OR\n      strTags += ' ' + segments[i++].value + ' ';\n    }\n    // Tag name\n    const tagName = segments[i++].value;\n    // Operator\n    const op = segments[i++].value;\n    if (op === OPERATOR_EQ || op === OPERATOR_NOTEQ) {\n      strTags += tagName + op + valueToString(segments[i++].value);\n    } else if (op === OPERATOR_EXISTS) {\n      strTags += tagName;\n    } else if (op === OPERATOR_NOTEXISTS) {\n      strTags += 'NOT ' + tagName;\n    } else if (op === OPERATOR_IN) {\n      const v = valuesToString(segments, i);\n      i = v.i;\n      strTags += `${tagName} IN [${v.values}]`;\n    } else if (op === OPERATOR_NOTIN) {\n      const v = valuesToString(segments, i);\n      i = v.i;\n      strTags += `${tagName} NOT IN [${v.values}]`;\n    }\n  }\n  return strTags;\n}\n\nfunction valuesToString(segments, i) {\n  let values = '';\n  let sep = '';\n  while (i < segments.length && segments[i].type === 'value') {\n    values += sep + valueToString(segments[i++].value);\n    sep = ',';\n  }\n  return {\n    values: values,\n    i: i\n  };\n}\n\nfunction valueToString(value) {\n  if ((value.charAt(0) === \"'\" && value.charAt(value.length-1) === \"'\")\n      || value.match(/^\\$?[a-zA-Z0-9_.]+$/g)) {\n    // Variable, simple literal or already single-quoted => keep as is\n    return value;\n  }\n  return `'${value}'`;\n}\n\n// Example:\n// Input string: \"fruit IN [pear, apple, peach] AND color=green\"\n// Output segment values: [\"fruit\", \"is in\", \"pear\", \"apple\", \"peach\", \"<plus-button>\", \"AND\", \"color\", \"=\", \"green\", \"<plus-button>\"]\nexport function stringToSegments(strTags, segmentFactory) {\n  if (strTags === undefined) {\n    return [];\n  }\n  let segments = [];\n  let cursor = 0;\n  let result;\n  while (cursor < strTags.length) {\n    if (cursor > 0) {\n      result = readLogicalOp(strTags, cursor);\n      cursor = result.cursor;\n      segments.push(segmentFactory.newCondition(result.value));\n    }\n    result = readWord(strTags, cursor);\n    cursor = result.cursor;\n    if (result.value.toUpperCase() === 'NOT') {\n      // Special case, 'not' keyword may be be read instead of tag name\n      result = readWord(strTags, cursor);\n      cursor = result.cursor;\n      segments.push(segmentFactory.newKey(result.value));\n      segments.push(segmentFactory.newOperator(OPERATOR_NOTEXISTS));\n    } else {\n      // It's tag name\n      segments.push(segmentFactory.newKey(result.value));\n      // Check next word without increasing cursor: if it's a logical operator, we're on an \"exists\" operation\n      result = readWord(strTags, cursor);\n      const nextCursor = skipWhile(strTags, result.cursor, c => c === ' ');\n      if (nextCursor >= strTags.length || result.value === OPERATOR_AND || result.value === OPERATOR_OR) {\n        segments.push(segmentFactory.newOperator(OPERATOR_EXISTS));\n      } else {\n        // Relational operation\n        result = readRelationalOp(strTags, cursor);\n        cursor = result.cursor;\n        segments.push(segmentFactory.newOperator(result.value));\n        if (result.value === '=' || result.value === '!=') {\n          result = readWord(strTags, cursor);\n          cursor = result.cursor;\n          segments.push(segmentFactory.newKeyValue(result.value));\n        } else {\n          // Enumeration\n          result = readEnumeration(strTags, cursor);\n          cursor = result.cursor;\n          for (let value of result.values) {\n            segments.push(segmentFactory.newKeyValue(value));\n          }\n        }\n      }\n    }\n    cursor = skipWhile(strTags, cursor, c => c === ' ');\n  }\n  return segments;\n}\n\nfunction readLogicalOp(strTags, cursor) {\n  cursor = skipWhile(strTags, cursor, c => c === ' ');\n  if (strTags.substr(cursor, 2).toUpperCase() === 'OR') {\n    return { cursor: cursor + 2, value: OPERATOR_OR };\n  }\n  if (strTags.substr(cursor, 3).toUpperCase() === 'AND') {\n    return { cursor: cursor + 3, value: OPERATOR_AND };\n  }\n  throw `Cannot parse tags string: logical operator expected near '${strTags.substr(cursor, 15)}'`;\n}\n\nfunction readWord(strTags, cursor) {\n  cursor = skipWhile(strTags, cursor, c => c === ' ');\n  const remaining = strTags.substr(cursor);\n  if (remaining.charAt(0) === \"'\") {\n    const first = cursor;\n    cursor = skipWhile(strTags, first+1, c => c !== \"'\") + 1;\n    return { cursor: cursor, value: strTags.substr(first, cursor - first) };\n  }\n  const word = remaining.match(/^(\\$?[a-zA-Z0-9_.]*)/)[0];\n  cursor += word.length;\n  return { cursor: cursor, value: word };\n}\n\nfunction readRelationalOp(strTags, cursor) {\n  cursor = skipWhile(strTags, cursor, c => c === ' ');\n  if (strTags.substr(cursor, 1).toUpperCase() === '=') {\n    return { cursor: cursor + 1, value: OPERATOR_EQ };\n  }\n  if (strTags.substr(cursor, 2).toUpperCase() === '!=') {\n    return { cursor: cursor + 2, value: OPERATOR_NOTEQ };\n  }\n  if (strTags.substr(cursor, 2).toUpperCase() === 'IN') {\n    return { cursor: cursor + 2, value: OPERATOR_IN };\n  }\n  if (strTags.substr(cursor, 6).toUpperCase() === 'NOT IN') {\n    return { cursor: cursor + 6, value: OPERATOR_NOTIN };\n  }\n  throw `Cannot parse tags string: relational operator expected near '${strTags.substr(cursor, 15)}'`;\n}\n\nfunction readEnumeration(strTags, cursor) {\n  let values = [];\n  cursor = skipWhile(strTags, cursor, c => c !== '[') + 1;\n  while (cursor < strTags.length) {\n    let result = readWord(strTags, cursor);\n    values.push(result.value);\n    cursor = skipWhile(strTags, result.cursor, c => c === ' ');\n    if (strTags.charAt(cursor) === ']') {\n      cursor++;\n      break;\n    }\n    if (strTags.charAt(cursor) === ',') {\n      cursor++;\n    } else {\n      throw `Cannot parse tags string: unexpected token in enumeration near '${strTags.substr(cursor, 15)}'`;\n    }\n  }\n  return { cursor: cursor, values: values };\n}\n\nfunction skipWhile(strTags, cursor, cond) {\n  while (cursor < strTags.length && cond(strTags.charAt(cursor))) {\n    cursor++;\n  }\n  return cursor;\n}\n\nfunction skipWhileNextNotIn(strTags, cursor, nextList) {\n  while (cursor < strTags.length) {\n    for (let expect of nextList) {\n      const actual = strTags.substr(cursor, expect.length);\n      if (actual === expect) {\n        return cursor;\n      }\n    }\n    cursor++;\n  }\n  return cursor;\n}\n"]}