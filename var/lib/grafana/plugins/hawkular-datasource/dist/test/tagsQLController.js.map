{"version":3,"sources":["../../src/tagsQLController.js"],"names":["convertFromKVPairs","segmentsToString","stringToSegments","OPERATOR_EQ","OPERATOR_NOTEQ","OPERATOR_IN","OPERATOR_NOTIN","OPERATOR_EXISTS","OPERATOR_NOTEXISTS","OPERATOR_AND","OPERATOR_OR","TagsQLController","uiSegmentSrv","datasource","$q","targetSupplier","removeTagSegment","newSegment","fake","value","removeValueSegment","target","tagsQL","tags","segments","push","newPlusButton","isInEnum","i","length","type","splice","segment","$index","when","newOperators","getContainingEnum","key","suggestTags","then","transformToSegments","getTagKeys","angular","copy","keys","promise","values","suggestTagKeys","index","nextSegment","newKeyValue","newKey","newOperator","newCondition","needOneRightOperand","isEnum","currentRightOperands","kvTags","undefined","map","tag","name","charAt","join","strTags","tagName","op","valueToString","v","valuesToString","sep","match","segmentFactory","cursor","result","readLogicalOp","readWord","toUpperCase","nextCursor","skipWhile","c","readRelationalOp","readEnumeration","substr","remaining","first","word","cond","skipWhileNextNotIn","nextList","expect","actual"],"mappings":"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","file":"tagsQLController.js","sourcesContent":["// \"Natural language\" operators\nconst OPERATOR_EQ = '=';\nconst OPERATOR_NOTEQ = '!=';\nconst OPERATOR_IN = 'is in';\nconst OPERATOR_NOTIN = 'is not in';\nconst OPERATOR_EXISTS = 'exists';\nconst OPERATOR_NOTEXISTS = 'doesn\\'t exist';\nconst OPERATOR_AND = 'AND';\nconst OPERATOR_OR = 'OR';\n\nexport class TagsQLController {\n\n  constructor(uiSegmentSrv, datasource, $q, targetSupplier)  {\n    this.uiSegmentSrv = uiSegmentSrv;\n    this.datasource = datasource;\n    this.$q = $q;\n    this.targetSupplier = targetSupplier;\n    this.removeTagSegment = uiSegmentSrv.newSegment({fake: true, value: '-- Remove tag --'});\n    this.removeValueSegment = uiSegmentSrv.newSegment({fake: true, value: '-- Remove value --'});\n  }\n\n  initTagsSegments() {\n    const target = this.targetSupplier();\n    if (!target.tagsQL && target.tags) {\n      // Compatibility, switching from older version\n      target.tagsQL = convertFromKVPairs(target.tags);\n    }\n    let segments = stringToSegments(target.tagsQL, this.uiSegmentSrv);\n    segments.push(this.uiSegmentSrv.newPlusButton());\n    // Fix plus-button: add it at the end of each enumeration\n    let isInEnum = false;\n    for (let i = 0; i < segments.length; i++) {\n      if (segments[i].type === 'operator' && (segments[i].value === OPERATOR_IN || segments[i].value === OPERATOR_NOTIN)) {\n        isInEnum = true;\n      } else if (isInEnum && segments[i].type !== 'value') {\n        segments.splice(i, 0, this.uiSegmentSrv.newPlusButton());\n        isInEnum = false;\n      }\n    }\n    return segments;\n  }\n\n  getTagsSegments(segments, segment, $index) {\n    // Get suggestions for available values in a given segment\n    if (segment.type === 'condition') {\n      return this.$q.when([this.uiSegmentSrv.newSegment(OPERATOR_AND), this.uiSegmentSrv.newSegment(OPERATOR_OR)]);\n    }\n    if (segment.type === 'operator') {\n      return this.$q.when(this.uiSegmentSrv.newOperators([OPERATOR_EQ, OPERATOR_NOTEQ, OPERATOR_EXISTS, OPERATOR_NOTEXISTS, OPERATOR_IN, OPERATOR_NOTIN]));\n    }\n    if (segment.type === 'plus-button') {\n      // Find previous operator to know if we're in an enumeration\n      let i = this.getContainingEnum(segments, $index);\n      if (i > 0) {\n        const key = segments[i-1].value;\n        return this.datasource.suggestTags(this.targetSupplier(), key)\n          .then(this.uiSegmentSrv.transformToSegments(false));\n      } else {\n        return this.getTagKeys();\n      }\n    } else if (segment.type === 'key')  {\n      return this.getTagKeys()\n          .then(keys => [angular.copy(this.removeTagSegment), ...keys]);\n    } else if (segment.type === 'value')  {\n      // Find preceding key\n      let i = $index - 2;\n      while (segments[i].type !== 'key') {\n        i--;\n      }\n      const key = segments[i].value;\n      let promise = this.datasource.suggestTags(this.targetSupplier(), key)\n        .then(this.uiSegmentSrv.transformToSegments(false));\n      if (segments[$index-1].type === 'value') {\n        // We're in an enumeration\n        promise = promise.then(values => [angular.copy(this.removeValueSegment), ...values]);\n      }\n      return promise;\n    }\n  }\n\n  // Returns -1 if not in enum, or the index of the operator if in enum\n  getContainingEnum(segments, $index) {\n    // Find previous operator to know if we're in an enumeration\n    let i = $index-1;\n    while (i >= 0) {\n      if (segments[i].type === 'operator') {\n        if (segments[i].value === OPERATOR_IN || segments[i].value === OPERATOR_NOTIN) {\n          return i;\n        }\n        return -1;\n      }\n      if (segments[i].type === 'plus-button') {\n        // There can be several plus-buttons. In that case, the user selected the last plus-button, ie. the one related to adding a new tag.\n        return -1;\n      }\n      i--;\n    }\n    return -1;\n  }\n\n  getTagKeys() {\n    return this.datasource.suggestTagKeys(this.targetSupplier())\n      .then(this.uiSegmentSrv.transformToSegments(false));\n  }\n\n  tagsSegmentChanged(segments, segment, index) {\n    if (segment.value === this.removeTagSegment.value) {\n      // Remove the whole tag sequence\n      // Compute number of segments to delete forward\n      let nextSegment = index + 1;\n      if (index > 0) {\n        // Also remove preceding AND/OR segment\n        index--;\n      }\n      while (nextSegment < segments.length) {\n        if (nextSegment === segments.length - 1) {\n          break;\n        }\n        if (segments[nextSegment].type === 'condition') {\n          if (index === 0) {\n            // Don't start query with a AND or OR, remove it.\n            nextSegment++;\n          }\n          break;\n        }\n        nextSegment++;\n      }\n      segments.splice(index, nextSegment - index);\n    } else if (segment.value === this.removeValueSegment.value) {\n      // We must be deleting a value from an enumeration\n      segments.splice(index, 1);\n    } else if (segment.type === 'plus-button') {\n      // Remove plus button\n      segments.splice(index, 1);\n      let i = this.getContainingEnum(segments, index);\n      if (i > 0) {\n        // We're in an enum, so add value\n        segments.splice(index, 0,\n          this.uiSegmentSrv.newKeyValue(segment.value),\n          this.uiSegmentSrv.newPlusButton());\n      } else {\n        // Add a default model for tag: \"<key> EXISTS\"\n        segments.splice(index, 0,\n          this.uiSegmentSrv.newKey(segment.value),\n          this.uiSegmentSrv.newOperator(OPERATOR_EXISTS),\n          this.uiSegmentSrv.newPlusButton());\n        if (index > 0) {\n          // Add leading \"AND\"\n          segments.splice(index, 0, this.uiSegmentSrv.newCondition(OPERATOR_AND));\n        }\n      }\n    } else {\n      if (segment.type === 'operator') {\n        // Is there a change in number of operands?\n        const needOneRightOperand = segment.value === OPERATOR_EQ || segment.value === OPERATOR_NOTEQ;\n        const isEnum = segment.value === OPERATOR_IN || segment.value === OPERATOR_NOTIN;\n        let currentRightOperands = 0;\n        while (segments[index+currentRightOperands+1].type === 'value') {\n          currentRightOperands++;\n        }\n        // If it's followed by a plus-button that is NOT the last element, then count it as a right operand as it must also be removed when we switch from enum to something else\n        if (segments[index+currentRightOperands+1].type === 'plus-button' && index+currentRightOperands+2 < segments.length) {\n          currentRightOperands++;\n        }\n        if (needOneRightOperand && currentRightOperands === 0) {\n          // Add tag value\n          segments.splice(index+1, 0, this.uiSegmentSrv.newKeyValue('select value'));\n        } else if (needOneRightOperand && currentRightOperands > 1) {\n          // Remove excedent\n          segments.splice(index+2, currentRightOperands-1);\n        } else if (!needOneRightOperand && !isEnum && currentRightOperands > 0) {\n          // Remove values\n          segments.splice(index+1, currentRightOperands);\n        } else if (isEnum) {\n          if (currentRightOperands === 0) {\n            // Add a value and plus-button\n            segments.splice(index+1, 0, this.uiSegmentSrv.newKeyValue('select value'), this.uiSegmentSrv.newPlusButton());\n          } else if (currentRightOperands === 1) {\n            // Just add plus-button after the value\n            segments.splice(index+2, 0, this.uiSegmentSrv.newPlusButton());\n          }\n        }\n      }\n      segments[index] = segment;\n    }\n    this.targetSupplier().tagsQL = segmentsToString(segments);\n  }\n}\n\nexport function convertFromKVPairs(kvTags) {\n  if (kvTags === undefined) {\n    return undefined;\n  }\n  return kvTags.map(tag => {\n    if (tag.value === '*' || tag.value === ' *') {\n      return tag.name;\n    }\n    if (tag.value.charAt(0) === '$') {\n      // it's a variable\n      return `${tag.name} IN [${tag.value}]`;\n    }\n    return `${tag.name}='${tag.value}'`;\n  }).join(' AND ');\n}\n\n// Example:\n// Input segment values: [\"fruit\", \"is in\", \"pear\", \"apple\", \"peach\", \"<plus-button>\", \"AND\", \"color\", \"=\", \"green\", \"<plus-button>\"]\n// Output string: \"fruit IN [pear, apple, peach] AND color=green\"\nexport function segmentsToString(segments) {\n  let strTags = '';\n  let i = 0;\n  while (i < segments.length) {\n    if (segments[i].type === 'plus-button') {\n      i++;\n      continue;\n    }\n    if (i != 0) {\n      // AND/OR\n      strTags += ' ' + segments[i++].value + ' ';\n    }\n    // Tag name\n    const tagName = segments[i++].value;\n    // Operator\n    const op = segments[i++].value;\n    if (op === OPERATOR_EQ || op === OPERATOR_NOTEQ) {\n      strTags += tagName + op + valueToString(segments[i++].value);\n    } else if (op === OPERATOR_EXISTS) {\n      strTags += tagName;\n    } else if (op === OPERATOR_NOTEXISTS) {\n      strTags += 'NOT ' + tagName;\n    } else if (op === OPERATOR_IN) {\n      const v = valuesToString(segments, i);\n      i = v.i;\n      strTags += `${tagName} IN [${v.values}]`;\n    } else if (op === OPERATOR_NOTIN) {\n      const v = valuesToString(segments, i);\n      i = v.i;\n      strTags += `${tagName} NOT IN [${v.values}]`;\n    }\n  }\n  return strTags;\n}\n\nfunction valuesToString(segments, i) {\n  let values = '';\n  let sep = '';\n  while (i < segments.length && segments[i].type === 'value') {\n    values += sep + valueToString(segments[i++].value);\n    sep = ',';\n  }\n  return {\n    values: values,\n    i: i\n  };\n}\n\nfunction valueToString(value) {\n  if ((value.charAt(0) === \"'\" && value.charAt(value.length-1) === \"'\")\n      || value.match(/^\\$?[a-zA-Z0-9_.]+$/g)) {\n    // Variable, simple literal or already single-quoted => keep as is\n    return value;\n  }\n  return `'${value}'`;\n}\n\n// Example:\n// Input string: \"fruit IN [pear, apple, peach] AND color=green\"\n// Output segment values: [\"fruit\", \"is in\", \"pear\", \"apple\", \"peach\", \"<plus-button>\", \"AND\", \"color\", \"=\", \"green\", \"<plus-button>\"]\nexport function stringToSegments(strTags, segmentFactory) {\n  if (strTags === undefined) {\n    return [];\n  }\n  let segments = [];\n  let cursor = 0;\n  let result;\n  while (cursor < strTags.length) {\n    if (cursor > 0) {\n      result = readLogicalOp(strTags, cursor);\n      cursor = result.cursor;\n      segments.push(segmentFactory.newCondition(result.value));\n    }\n    result = readWord(strTags, cursor);\n    cursor = result.cursor;\n    if (result.value.toUpperCase() === 'NOT') {\n      // Special case, 'not' keyword may be be read instead of tag name\n      result = readWord(strTags, cursor);\n      cursor = result.cursor;\n      segments.push(segmentFactory.newKey(result.value));\n      segments.push(segmentFactory.newOperator(OPERATOR_NOTEXISTS));\n    } else {\n      // It's tag name\n      segments.push(segmentFactory.newKey(result.value));\n      // Check next word without increasing cursor: if it's a logical operator, we're on an \"exists\" operation\n      result = readWord(strTags, cursor);\n      const nextCursor = skipWhile(strTags, result.cursor, c => c === ' ');\n      if (nextCursor >= strTags.length || result.value === OPERATOR_AND || result.value === OPERATOR_OR) {\n        segments.push(segmentFactory.newOperator(OPERATOR_EXISTS));\n      } else {\n        // Relational operation\n        result = readRelationalOp(strTags, cursor);\n        cursor = result.cursor;\n        segments.push(segmentFactory.newOperator(result.value));\n        if (result.value === '=' || result.value === '!=') {\n          result = readWord(strTags, cursor);\n          cursor = result.cursor;\n          segments.push(segmentFactory.newKeyValue(result.value));\n        } else {\n          // Enumeration\n          result = readEnumeration(strTags, cursor);\n          cursor = result.cursor;\n          for (let value of result.values) {\n            segments.push(segmentFactory.newKeyValue(value));\n          }\n        }\n      }\n    }\n    cursor = skipWhile(strTags, cursor, c => c === ' ');\n  }\n  return segments;\n}\n\nfunction readLogicalOp(strTags, cursor) {\n  cursor = skipWhile(strTags, cursor, c => c === ' ');\n  if (strTags.substr(cursor, 2).toUpperCase() === 'OR') {\n    return { cursor: cursor + 2, value: OPERATOR_OR };\n  }\n  if (strTags.substr(cursor, 3).toUpperCase() === 'AND') {\n    return { cursor: cursor + 3, value: OPERATOR_AND };\n  }\n  throw `Cannot parse tags string: logical operator expected near '${strTags.substr(cursor, 15)}'`;\n}\n\nfunction readWord(strTags, cursor) {\n  cursor = skipWhile(strTags, cursor, c => c === ' ');\n  const remaining = strTags.substr(cursor);\n  if (remaining.charAt(0) === \"'\") {\n    const first = cursor;\n    cursor = skipWhile(strTags, first+1, c => c !== \"'\") + 1;\n    return { cursor: cursor, value: strTags.substr(first, cursor - first) };\n  }\n  const word = remaining.match(/^(\\$?[a-zA-Z0-9_.]*)/)[0];\n  cursor += word.length;\n  return { cursor: cursor, value: word };\n}\n\nfunction readRelationalOp(strTags, cursor) {\n  cursor = skipWhile(strTags, cursor, c => c === ' ');\n  if (strTags.substr(cursor, 1).toUpperCase() === '=') {\n    return { cursor: cursor + 1, value: OPERATOR_EQ };\n  }\n  if (strTags.substr(cursor, 2).toUpperCase() === '!=') {\n    return { cursor: cursor + 2, value: OPERATOR_NOTEQ };\n  }\n  if (strTags.substr(cursor, 2).toUpperCase() === 'IN') {\n    return { cursor: cursor + 2, value: OPERATOR_IN };\n  }\n  if (strTags.substr(cursor, 6).toUpperCase() === 'NOT IN') {\n    return { cursor: cursor + 6, value: OPERATOR_NOTIN };\n  }\n  throw `Cannot parse tags string: relational operator expected near '${strTags.substr(cursor, 15)}'`;\n}\n\nfunction readEnumeration(strTags, cursor) {\n  let values = [];\n  cursor = skipWhile(strTags, cursor, c => c !== '[') + 1;\n  while (cursor < strTags.length) {\n    let result = readWord(strTags, cursor);\n    values.push(result.value);\n    cursor = skipWhile(strTags, result.cursor, c => c === ' ');\n    if (strTags.charAt(cursor) === ']') {\n      cursor++;\n      break;\n    }\n    if (strTags.charAt(cursor) === ',') {\n      cursor++;\n    } else {\n      throw `Cannot parse tags string: unexpected token in enumeration near '${strTags.substr(cursor, 15)}'`;\n    }\n  }\n  return { cursor: cursor, values: values };\n}\n\nfunction skipWhile(strTags, cursor, cond) {\n  while (cursor < strTags.length && cond(strTags.charAt(cursor))) {\n    cursor++;\n  }\n  return cursor;\n}\n\nfunction skipWhileNextNotIn(strTags, cursor, nextList) {\n  while (cursor < strTags.length) {\n    for (let expect of nextList) {\n      const actual = strTags.substr(cursor, expect.length);\n      if (actual === expect) {\n        return cursor;\n      }\n    }\n    cursor++;\n  }\n  return cursor;\n}\n"]}