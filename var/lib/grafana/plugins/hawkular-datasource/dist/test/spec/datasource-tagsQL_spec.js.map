{"version":3,"sources":["../../../spec/datasource-tagsQL_spec.js"],"names":["describe","ctx","instanceSettings","beforeEach","$q","backendSrv","datasourceRequest","when","data","templateSrv","replace","target","vars","ds","it","query","targets","then","expect","result","to","have","property","with","length","done","err","options","range","from","tagsQL","type","rate","request","deep","equal","start","end","tags","order","status","seriesAggFn","timeAggFn","buckets","stacked","limit"],"mappings":"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","file":"datasource-tagsQL_spec.js","sourcesContent":["import {Datasource} from '../module';\nimport Q from 'q';\nimport {getSettings, expectRequest} from './test-util';\n\ndescribe('HawkularDatasource with tagsQL', () => {\n  const ctx = {};\n  const instanceSettings = getSettings();\n\n  beforeEach(() => {\n    ctx.$q = Q;\n    ctx.backendSrv = {};\n    ctx.backendSrv.datasourceRequest = request => {\n      return ctx.$q.when({data: {'Implementation-Version': '0.24.0'}})\n    };\n    ctx.templateSrv = {\n        replace: (target, vars) => target\n    };\n    ctx.ds = new Datasource(instanceSettings, ctx.$q, ctx.backendSrv, ctx.templateSrv);\n  });\n\n  it('should return an empty array when no targets are set', done => {\n    ctx.ds.query({targets: []}).then(result => {\n      expect(result).to.have.property('data').with.length(0);\n    }).then(v => done(), err => done(err));\n  });\n\n  it('should query by tags QL', done => {\n    const options = {\n      range: {\n        from: 15,\n        to: 30\n      },\n      targets: [{\n        tagsQL: 'type=memory AND host=myhost',\n        type: 'gauge',\n        rate: false\n      }]\n    };\n\n    ctx.backendSrv.datasourceRequest = request => {\n      expectRequest(request, 'POST', 'gauges/raw/query');\n      expect(request.data).to.deep.equal({\n        start: options.range.from,\n        end: options.range.to,\n        tags: 'type=memory AND host=myhost',\n        order: 'ASC'\n      });\n\n      return ctx.$q.when({\n        status: 200,\n        data: []\n      });\n    };\n\n    ctx.ds.query(options).then(v => done(), err => done(err));\n  });\n\n  it('should return aggregated stats by tags QL', done => {\n\n    const options = {\n      range: {\n        from: 15,\n        to: 30\n      },\n      targets: [{\n        seriesAggFn: 'sum',\n        timeAggFn: 'max',\n        tagsQL: 'type=memory',\n        type: 'gauge',\n        rate: false\n      }]\n    };\n\n    ctx.backendSrv.datasourceRequest = request => {\n      expectRequest(request, 'POST', 'gauges/stats/query');\n      expect(request.data).to.deep.equal({\n        start: options.range.from,\n        end: options.range.to,\n        tags: 'type=memory',\n        buckets: 1,\n        stacked: true\n      });\n\n      return ctx.$q.when({\n        status: 200,\n        data: []\n      });\n    };\n\n    ctx.ds.query(options).then(v => done(), err => done(err));\n  });\n\n  it('should return live stats with tagsQL', done => {\n\n    const options = {\n      range: {\n        from: 15,\n        to: 30\n      },\n      targets: [{\n        seriesAggFn: 'sum',\n        timeAggFn: 'live',\n        tagsQL: 'type=memory',\n        type: 'gauge',\n        rate: false\n      }]\n    };\n\n    ctx.backendSrv.datasourceRequest = request => {\n      expectRequest(request, 'POST', 'gauges/raw/query');\n      expect(request.data.limit).to.equal(1);\n      expect(request.data.tags).to.equal('type=memory');\n\n      return ctx.$q.when({\n        status: 200,\n        data: []\n      });\n    };\n\n    ctx.ds.query(options).then(v => done(), err => done(err));\n  });\n});\n"]}