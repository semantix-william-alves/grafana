{"version":3,"sources":["../../../spec/tags-ql_spec.js"],"names":["describe","segmentFactory","newSegment","arg","newKey","type","value","key","newCondition","cond","newOperator","op","newKeyValue","v","it","result","expect","to","deep","equal","done","segments","undefined","name"],"mappings":"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","file":"tags-ql_spec.js","sourcesContent":["import {segmentsToString, stringToSegments, convertFromKVPairs} from '../tagsQLController';\nimport Q from \"q\";\n\ndescribe('TagsQL', () => {\n\n  const segmentFactory = {\n    newSegment: arg => arg,\n    newKey: key => ({type: 'key', value: key}),\n    newCondition: cond => ({type: 'condition', value: cond}),\n    newOperator: op => ({type: 'operator', value: op}),\n    newKeyValue: v => ({type: 'value', value: v})\n  };\n\n  it('should convert empty segments to empty string', done => {\n    const result = segmentsToString([]);\n    expect(result).to.deep.equal(\"\");\n    done();\n  });\n\n  it('should convert segments to string', done => {\n    const segments = [\n      { type: 'key', value: 'hostname' },\n      { type: 'operator', value: 'exists' },\n      { type: 'condition', value: 'AND' },\n      { type: 'key', value: 'pod' },\n      { type: 'operator', value: '!=' },\n      { type: 'value', value: 'unknown' }\n    ];\n    const result = segmentsToString(segments);\n    expect(result).to.deep.equal(\"hostname AND pod!=unknown\");\n    done();\n  });\n\n  it('should convert segments with not exist to string', done => {\n    const segments = [\n      { type: 'key', value: 'hostname' },\n      { type: 'operator', value: 'doesn\\'t exist' },\n      { type: 'condition', value: 'AND' },\n      { type: 'key', value: 'pod' },\n      { type: 'operator', value: '!=' },\n      { type: 'value', value: 'unknown' }\n    ];\n    const result = segmentsToString(segments);\n    expect(result).to.deep.equal(\"NOT hostname AND pod!=unknown\");\n    done();\n  });\n\n  it('should convert empty string to empty segments', done => {\n    const result = stringToSegments(\"\", segmentFactory);\n    expect(result).to.deep.equal([]);\n    done();\n  });\n\n  it('should convert undefined string to empty segments', done => {\n    const result = stringToSegments(undefined, segmentFactory);\n    expect(result).to.deep.equal([]);\n    done();\n  });\n\n  it('should convert string to segments allowing spaces everywhere', done => {\n    const result = stringToSegments(\"  pod  !=  'unknown pod  '  \", segmentFactory);\n    expect(result).to.deep.equal([\n      { type: 'key', value: 'pod' },\n      { type: 'operator', value: '!=' },\n      { type: 'value', value: \"'unknown pod  '\" }\n    ]);\n    done();\n  });\n\n  it('should convert string to segments with single-quoted value having spaces', done => {\n    const result = stringToSegments(\"NOT hostname AND pod!='unknown pod'\", segmentFactory);\n    expect(result).to.deep.equal([\n      { type: 'key', value: 'hostname' },\n      { type: 'operator', value: 'doesn\\'t exist' },\n      { type: 'condition', value: 'AND' },\n      { type: 'key', value: 'pod' },\n      { type: 'operator', value: '!=' },\n      { type: 'value', value: \"'unknown pod'\" }\n    ]);\n    done();\n  });\n\n  it('should convert string to segments with unquoted value', done => {\n    const result = stringToSegments(\"pod != unknown AND hostname  \", segmentFactory);\n    expect(result).to.deep.equal([\n      { type: 'key', value: 'pod' },\n      { type: 'operator', value: '!=' },\n      { type: 'value', value: 'unknown' },\n      { type: 'condition', value: 'AND' },\n      { type: 'key', value: 'hostname' },\n      { type: 'operator', value: 'exists' }\n    ]);\n    done();\n  });\n\n  it('should convert string to segments with single value alone', done => {\n    const result = stringToSegments(\"hostname\", segmentFactory);\n    expect(result).to.deep.equal([\n      { type: 'key', value: 'hostname' },\n      { type: 'operator', value: 'exists' }\n    ]);\n    done();\n  });\n\n  it('should convert string to segments with no space around equal', done => {\n    const result = stringToSegments(\"pod=unknown\", segmentFactory);\n    expect(result).to.deep.equal([\n      { type: 'key', value: 'pod' },\n      { type: 'operator', value: '=' },\n      { type: 'value', value: 'unknown' }\n    ]);\n    done();\n  });\n\n  it('should convert string to segments with no space around not equal', done => {\n    const result = stringToSegments(\"pod!=unknown\", segmentFactory);\n    expect(result).to.deep.equal([\n      { type: 'key', value: 'pod' },\n      { type: 'operator', value: '!=' },\n      { type: 'value', value: 'unknown' }\n    ]);\n    done();\n  });\n\n  it('should convert segment with enumeration to string', done => {\n    const segments = [\n      { type: 'key', value: 'hostname' },\n      { type: 'operator', value: 'exists' },\n      { type: 'condition', value: 'AND' },\n      { type: 'key', value: 'pod' },\n      { type: 'operator', value: 'is not in' },\n      { type: 'value', value: 'abc' },\n      { type: 'value', value: 'def' }\n    ];\n    const result = segmentsToString(segments);\n    expect(result).to.deep.equal(\"hostname AND pod NOT IN [abc,def]\");\n    done();\n  });\n\n  it('should convert segment with enumeration and plus button to string', done => {\n    const segments = [\n      { type: 'key', value: 'hostname' },\n      { type: 'operator', value: 'is in' },\n      { type: 'value', value: 'alpha' },\n      { type: 'value', value: 'beta' },\n      { type: 'plus-button', value: '' },\n      { type: 'condition', value: 'AND' },\n      { type: 'key', value: 'pod' },\n      { type: 'operator', value: 'is not in' },\n      { type: 'value', value: 'abc' },\n      { type: 'value', value: 'def' },\n      { type: 'plus-button', value: '' },\n      { type: 'plus-button', value: '' }\n    ];\n    const result = segmentsToString(segments);\n    expect(result).to.deep.equal(\"hostname IN [alpha,beta] AND pod NOT IN [abc,def]\");\n    done();\n  });\n\n  it('should convert segment with enumeration with single quotes to string', done => {\n    const segments = [\n      { type: 'key', value: 'pod' },\n      { type: 'operator', value: 'is in' },\n      { type: 'value', value: \"'a b c'\" }\n    ];\n    const result = segmentsToString(segments);\n    expect(result).to.deep.equal(\"pod IN ['a b c']\");\n    done();\n  });\n\n  it('should use quotes when non-alphadecimal characters are found except for variables', done => {\n    const segments = [\n      { type: 'key', value: 'pod' },\n      { type: 'operator', value: 'is in' },\n      { type: 'value', value: \"a b c\" },\n      { type: 'value', value: \"def\" },\n      { type: 'value', value: \"+33/10\" },\n      { type: 'value', value: \"$variable\" }\n    ];\n    const result = segmentsToString(segments);\n    expect(result).to.deep.equal(\"pod IN ['a b c',def,'+33/10',$variable]\");\n    done();\n  });\n\n  it('should accept usual alphadecimal variable name', done => {\n    const segments = [\n      { type: 'key', value: 'pod_id' },\n      { type: 'operator', value: 'is in' },\n      { type: 'value', value: \"$var_iable_01234\" }\n    ];\n    const result = segmentsToString(segments);\n    expect(result).to.deep.equal(\"pod_id IN [$var_iable_01234]\");\n    done();\n  });\n\n  it('should accept usual alphadecimal variable name in back conversion', done => {\n    const result = stringToSegments(\"pod_id NOT IN [$var_iable_01234]\", segmentFactory);\n    expect(result).to.deep.equal([\n      { type: 'key', value: 'pod_id' },\n      { type: 'operator', value: 'is not in' },\n      { type: 'value', value: \"$var_iable_01234\" }\n    ]);\n    done();\n  });\n\n  it('should accept dot in variable name', done => {\n    const segments = [\n      { type: 'key', value: 'pod.id' },\n      { type: 'operator', value: 'is in' },\n      { type: 'value', value: \"$var_iable_01234\" }\n    ];\n    const result = segmentsToString(segments);\n    expect(result).to.deep.equal(\"pod.id IN [$var_iable_01234]\");\n    done();\n  });\n\n  it('should accept dot in variable name for back conversion', done => {\n    const result = stringToSegments(\"pod.id NOT IN [$var_iable_01234]\", segmentFactory);\n    expect(result).to.deep.equal([\n      { type: 'key', value: 'pod.id' },\n      { type: 'operator', value: 'is not in' },\n      { type: 'value', value: \"$var_iable_01234\" }\n    ]);\n    done();\n  });\n\n  it('should convert string with enumeration to segments', done => {\n    const result = stringToSegments(\"hostname AND pod NOT IN ['abc','def']\", segmentFactory);\n    expect(result).to.deep.equal([\n      { type: 'key', value: 'hostname' },\n      { type: 'operator', value: 'exists' },\n      { type: 'condition', value: 'AND' },\n      { type: 'key', value: 'pod' },\n      { type: 'operator', value: 'is not in' },\n      { type: 'value', value: \"'abc'\" },\n      { type: 'value', value: \"'def'\" }\n    ]);\n    done();\n  });\n\n  it('should convert segment with enumeration only to string', done => {\n    const segments = [\n      { type: 'key', value: 'pod' },\n      { type: 'operator', value: 'is in' },\n      { type: 'value', value: 'abc' },\n      { type: 'value', value: 'def' }\n    ];\n    const result = segmentsToString(segments);\n    expect(result).to.deep.equal(\"pod IN [abc,def]\");\n    done();\n  });\n\n  it('should convert string with enumeration only with quotes and spaces to segments', done => {\n    const result = stringToSegments(\"  pod  IN [  'abc' ,  'def ghi'  ]  \", segmentFactory);\n    expect(result).to.deep.equal([\n      { type: 'key', value: 'pod' },\n      { type: 'operator', value: 'is in' },\n      { type: 'value', value: \"'abc'\" },\n      { type: 'value', value: \"'def ghi'\" }\n    ]);\n    done();\n  });\n\n  it('should convert from key-value pairs', done => {\n    const result = convertFromKVPairs([\n      { name: \"hostname\", value: \"*\" },\n      { name: \"app\", value: \"aloha\" },\n      { name: \"pod\", value: \"unknown\" }\n    ]);\n    expect(result).to.deep.equal(\"hostname AND app='aloha' AND pod='unknown'\");\n    done();\n  });\n\n  it('should convert from key-value pairs with variable', done => {\n    const result = convertFromKVPairs([\n      { name: \"hostname\", value: \"*\" },\n      { name: \"app\", value: \"$app\" }\n    ]);\n    expect(result).to.deep.equal(\"hostname AND app IN [$app]\");\n    done();\n  });\n});\n"]}