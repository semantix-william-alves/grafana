{"version":3,"sources":["../../src/datasource/kentikProxy.js"],"names":["getUTCTimestamp","ts","Date","getTime","getTimezoneOffset","getHash","queryObj","query","_","cloneDeep","starting_time","ending_time","JSON","stringify","getMaxRefreshInterval","interval","parse","moment","duration","angular","KentikProxy","backendSrv","kentikAPISrv","kentikAPI","cache","cacheUpdateInterval","requestCachingIntervals","getDevices","bind","cached_query","hash","shouldInvoke","invokeTopXDataQuery","then","timestamp","result","console","log","Promise","resolve","kentik_query","query_range","cache_starting_time","cache_ending_time","cached_query_range","max_refresh_interval","Math","abs","field","value","getFieldValues","module","service"],"mappings":";;;;;;;;;;;;;AAKA,WAASA,eAAT,GAA2B;AACzB,QAAIC,KAAK,IAAIC,IAAJ,EAAT;AACA,WAAOD,GAAGE,OAAH,KAAeF,GAAGG,iBAAH,KAAyB,EAAzB,GAA8B,IAApD;AACD;;AAED;AACA,WAASC,OAAT,CAAiBC,QAAjB,EAA2B;AACzB,QAAIC,QAAQC,EAAEC,SAAF,CAAYH,QAAZ,CAAZ;AACAC,UAAMG,aAAN,GAAsB,IAAtB;AACAH,UAAMI,WAAN,GAAoB,IAApB;AACA,WAAOC,KAAKC,SAAL,CAAeN,KAAf,CAAP;AACD;;AAED;AACA,WAASO,qBAAT,CAA+BP,KAA/B,EAAsC;AACpC,QAAIQ,WAAWb,KAAKc,KAAL,CAAWT,MAAMI,WAAjB,IAAgCT,KAAKc,KAAL,CAAWT,MAAMG,aAAjB,CAA/C;AACA,QAAIK,WAAWE,OAAOC,QAAP,CAAgB,CAAhB,EAAmB,QAAnB,CAAf,EAA6C;AAC3C,aAAO,KAAK,EAAL,GAAU,IAAjB,CAD2C,CACpB;AACxB,KAFD,MAEO,IAAIH,WAAWE,OAAOC,QAAP,CAAgB,CAAhB,EAAmB,KAAnB,CAAf,EAA0C;AAC/C,aAAO,KAAK,EAAL,GAAU,IAAjB,CAD+C,CACxB;AACxB,KAFM,MAEA;AACL,aAAO,IAAI,EAAJ,GAAS,IAAhB,CADK,CACiB;AACvB;AACF;;;;AA5BMC,a;;AACAX,O;;AACAS,Y;;;;;;;;;;;;;;;;;;;;;AA4BDG,iB;AACJ,6BAAYC,UAAZ,EAAwBC,YAAxB,EAAsC;AAAA;;AACpC,eAAKC,SAAL,GAAiBD,YAAjB;AACA,eAAKE,KAAL,GAAa,EAAb;AACA,eAAKC,mBAAL,GAA2B,IAAI,EAAJ,GAAS,IAApC,CAHoC,CAGM;AAC1C,eAAKC,uBAAL,GAA+B;AAC7B,kBAAM;AADuB,WAA/B;;AAIA,eAAKC,UAAL,GAAkB,KAAKJ,SAAL,CAAeI,UAAf,CAA0BC,IAA1B,CAA+B,KAAKL,SAApC,CAAlB;AACD;;;;8CAEmBhB,K,EAAO;AAAA;;AACzB,gBAAIsB,eAAerB,EAAEC,SAAF,CAAYF,KAAZ,CAAnB;AACA,gBAAIuB,OAAOzB,QAAQwB,YAAR,CAAX;;AAEA,gBAAI,KAAKE,YAAL,CAAkBxB,KAAlB,CAAJ,EAA8B;AAC5B;AACA,qBAAO,KAAKgB,SAAL,CAAeS,mBAAf,CAAmCzB,KAAnC,EACN0B,IADM,CACD,kBAAU;AACd,oBAAIC,YAAYlC,iBAAhB;;AAEA,sBAAKwB,KAAL,CAAWM,IAAX,IAAmB;AACjBI,6BAAWA,SADM;AAEjB3B,yBAAOsB,YAFU;AAGjBM,0BAAQA;AAHS,iBAAnB;AAKAC,wBAAQC,GAAR,CAAY,qBAAZ;AACA,uBAAOF,MAAP;AACD,eAXM,CAAP;AAYD,aAdD,MAcO;AACL;AACAC,sBAAQC,GAAR,CAAY,uBAAZ;AACA,qBAAOC,QAAQC,OAAR,CAAgB,KAAKf,KAAL,CAAWM,IAAX,EAAiBK,MAAjC,CAAP;AACD;AACF;;;uCAGY5B,K,EAAO;AAClB,gBAAIiC,eAAejC,KAAnB;AACA,gBAAIuB,OAAOzB,QAAQmC,YAAR,CAAX;AACA,gBAAIN,YAAYlC,iBAAhB;;AAEA,gBAAIU,gBAAgBR,KAAKc,KAAL,CAAWwB,aAAa9B,aAAxB,CAApB;AACA,gBAAIC,cAAcT,KAAKc,KAAL,CAAWwB,aAAa7B,WAAxB,CAAlB;AACA,gBAAI8B,cAAc9B,cAAcD,aAAhC;;AAEA,gBAAIgC,sBAAsB,KAAKlB,KAAL,CAAWM,IAAX,IAAmB5B,KAAKc,KAAL,CAAW,KAAKQ,KAAL,CAAWM,IAAX,EAAiBvB,KAAjB,CAAuBG,aAAlC,CAAnB,GAAsE,IAAhG;AACA,gBAAIiC,oBAAoB,KAAKnB,KAAL,CAAWM,IAAX,IAAmB5B,KAAKc,KAAL,CAAW,KAAKQ,KAAL,CAAWM,IAAX,EAAiBvB,KAAjB,CAAuBI,WAAlC,CAAnB,GAAoE,IAA5F;AACA,gBAAIiC,qBAAqBD,oBAAoBD,mBAA7C;;AAEA,gBAAIG,uBAAuB/B,sBAAsB0B,YAAtB,CAA3B;;AAEA,mBACE,CAAC,KAAKhB,KAAL,CAAWM,IAAX,CAAD,IACAI,YAAYvB,WAAZ,GAA0BkC,oBAD1B,IAEC,KAAKrB,KAAL,CAAWM,IAAX,MACCI,YAAYS,iBAAZ,GAAgCE,oBAAhC,IACAnC,gBAAgBgC,mBADhB,IAEAI,KAAKC,GAAL,CAASN,cAAcG,kBAAvB,IAA6C,KAAK,IAHnD,CAGwD;AAHxD,aAHH;AASD;;;yCAEcI,K,EAAO;AAAA;;AACpB,gBAAI/C,KAAKD,iBAAT;AACA,gBAAI,KAAKwB,KAAL,CAAWwB,KAAX,KAAqB/C,KAAK,KAAKuB,KAAL,CAAWwB,KAAX,EAAkB/C,EAAvB,GAA4B,KAAKwB,mBAA1D,EAA+E;AAC7E,qBAAOa,QAAQC,OAAR,CAAgB,KAAKf,KAAL,CAAWwB,KAAX,EAAkBC,KAAlC,CAAP;AACD,aAFD,MAEO;AACL,qBAAO,KAAK1B,SAAL,CAAe2B,cAAf,CAA8BF,KAA9B,EACNf,IADM,CACD,kBAAU;AACdhC,qBAAKD,iBAAL;AACA,uBAAKwB,KAAL,CAAWwB,KAAX,IAAoB;AAClB/C,sBAAIA,EADc;AAElBgD,yBAAOd;AAFW,iBAApB;;AAKA,uBAAOA,MAAP;AACD,eATM,CAAP;AAUD;AACF;;;;;;AAGHhB,cACGgC,MADH,CACU,kBADV,EAEGC,OAFH,CAEW,gBAFX,EAE6BhC,WAF7B","file":"kentikProxy.js","sourcesContent":["import angular from 'angular';\nimport _ from 'lodash';\nimport moment from 'moment';\nimport './kentikAPI';\n\nfunction getUTCTimestamp() {\n  let ts = new Date();\n  return ts.getTime() + ts.getTimezoneOffset() * 60 * 1000;\n}\n\n// Get hash of Kentik query\nfunction getHash(queryObj) {\n  let query = _.cloneDeep(queryObj);\n  query.starting_time = null;\n  query.ending_time = null;\n  return JSON.stringify(query);\n}\n\n// Prevent too frequent queries\nfunction getMaxRefreshInterval(query) {\n  let interval = Date.parse(query.ending_time) - Date.parse(query.starting_time);\n  if (interval > moment.duration(1, 'months')) {\n    return 60 * 60 * 1000; // 1 hour\n  } else if (interval > moment.duration(1, 'day')) {\n    return 15 * 60 * 1000; // 15 min\n  } else {\n    return 5 * 60 * 1000; // 5 min\n  }\n}\n\nclass KentikProxy {\n  constructor(backendSrv, kentikAPISrv) {\n    this.kentikAPI = kentikAPISrv;\n    this.cache = {};\n    this.cacheUpdateInterval = 5 * 60 * 1000; // 5 min by default\n    this.requestCachingIntervals = {\n      '1d': 0\n    };\n\n    this.getDevices = this.kentikAPI.getDevices.bind(this.kentikAPI);\n  }\n\n  invokeTopXDataQuery(query) {\n    let cached_query = _.cloneDeep(query);\n    let hash = getHash(cached_query);\n\n    if (this.shouldInvoke(query)) {\n      // Invoke query\n      return this.kentikAPI.invokeTopXDataQuery(query)\n      .then(result => {\n        let timestamp = getUTCTimestamp();\n\n        this.cache[hash] = {\n          timestamp: timestamp,\n          query: cached_query,\n          result: result\n        };\n        console.log('Invoke Kentik query');\n        return result;\n      });\n    } else {\n      // Get from cache\n      console.log('Get result from cache');\n      return Promise.resolve(this.cache[hash].result);\n    }\n  }\n\n  // Decide, is query shold be invoked or get data from cahce?\n  shouldInvoke(query) {\n    let kentik_query = query;\n    let hash = getHash(kentik_query);\n    let timestamp = getUTCTimestamp();\n\n    let starting_time = Date.parse(kentik_query.starting_time);\n    let ending_time = Date.parse(kentik_query.ending_time);\n    let query_range = ending_time - starting_time;\n\n    let cache_starting_time = this.cache[hash] ? Date.parse(this.cache[hash].query.starting_time) : null;\n    let cache_ending_time = this.cache[hash] ? Date.parse(this.cache[hash].query.ending_time) : null;\n    let cached_query_range = cache_ending_time - cache_starting_time;\n\n    let max_refresh_interval = getMaxRefreshInterval(kentik_query);\n\n    return (\n      !this.cache[hash] ||\n      timestamp - ending_time > max_refresh_interval ||\n      (this.cache[hash] && (\n        timestamp - cache_ending_time > max_refresh_interval ||\n        starting_time < cache_starting_time ||\n        Math.abs(query_range - cached_query_range) > 60 * 1000 // is time range changed?\n      ))\n    );\n  }\n\n  getFieldValues(field) {\n    let ts = getUTCTimestamp();\n    if (this.cache[field] && ts - this.cache[field].ts < this.cacheUpdateInterval) {\n      return Promise.resolve(this.cache[field].value);\n    } else {\n      return this.kentikAPI.getFieldValues(field)\n      .then(result => {\n        ts = getUTCTimestamp();\n        this.cache[field] = {\n          ts: ts,\n          value: result\n        };\n\n        return result;\n      });\n    }\n  }\n}\n\nangular\n  .module('grafana.services')\n  .service('kentikProxySrv', KentikProxy);\n"]}